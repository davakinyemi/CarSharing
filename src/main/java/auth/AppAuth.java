package auth;

import app.App;
import auth.beta.actioncode.ActionCodeResult;
import auth.beta.idtoken.IdTokenListener;
import auth.listener.AuthStateListener;
import entity.beta.appentity.AppEntity;
import entity.user.UserEntity;
import exception.authexception.*;
import job.Job;

public abstract class AppAuth {
    // register a listener to changes in super entity (user/admin/vehicle via admin) auth state
    // there can be more than one listener registered at the same time for one or more auth instances
    // listeners call back in the implementation thread on the following events:
    // right after listener is registered
    // when entity signs in
    // when current entity signs out
    // when current entity changes
    public void addAuthStateListener(AuthStateListener listener)
    class CompositeListener implements OnEventListener{
        private List<OnEventListener> addAuthStateListener= new ArrayList<OnEventListener>();

        public void addAuthStateListener (OnEventListener listener) {
            AuthStateListener.add(listener);
        }

        public void onEvent(Event e) {
            for(OnEventListener listener:AuthStateListener) {
                listener.onEvent(e);
            }
        }
    }

}


    public void removeAuthStateListener(AuthStateListener listener){

        AuthStateListener.remove(AuthStateListener.class, listener);
    }

    // registers a listener to changes in id token auth state
    // there can be more than one listener registered at the same time for one or more auth instances
    // listeners call back in implementation thread on the following events:
    // right after listener is registered
    // when a super entity signs in
    // when current entity signs out
    // when current entity changes
    public void addIdTokenListener(IdTokenListener listener)
    class CompositeListener implements OnEventListener{
        private List<OnEventListener> addIdTokenListener= new ArrayList<OnEventListener>();

        public void addIdTokenListener (OnEventListener listener) {
            AuthStateListener.add(listener);
        }

        public void onEvent(Event e) {
            for(OnEventListener listener:IdTokenListener) {
                listener.onEvent(e);
            }
        }
    }

        I
    public void removeIdTokenListener(IdTokenListener listener){

        IdTokenListener.remove(IdTokenListener.class, listener);
    }

    // applies the given code (any valid out of band code)

    public void subscribe(CompletableEmitter emitter) throws Exception {
        RxCompletableHandler.assignOnTask(emitter, firebaseAuth.applyActionCode(code));
        };
        @Test
        public Job<Void> applyAccessCode(String code) {
            TestObserver authTestObserver = RxFirebaseAuth
            .applyAccessCode(firebaseAuth, ANY_CODE)
            .test();
            testOnCompleteListener.getValue().onComplete(voidTask);
            verify(firebaseAuth).applyAccessCode(eq(ANY_CODE));
            authTestObserver.assertNoErrors()
            .assertValueSet(Collections.singletonList(voidTask))
            .assertComplete()
            .dispose();

            return null;
    }

    // checks that code given is valid.
    // Code is generated by sendPasswordResetEmail(String) or UserEntity.sendEmailVerification
    // Code is valid fora single use
    // returns Job of AccessCodeReport which can be used to see the result via the AccessCodeResult
    // AccessCodeResult hold user email for which AccessCode is valid, as well as the AccessCodeOperation which is being performed

    public void subscribe(MaybeEmitter<AccessCodeResult> emitter) throws Exception {
        RxHandler.assignOnTask(emitter, firebaseAuth.checkAccessCode(code));
        };
        @Test
        public Job<ActionCodeResult> checkAccessCode(String code){
        TestObserver<ActionCodeResult> authTestObserver = RxFirebaseAuth
        .checkActionCode(firebaseAuth, ANY_CODE)
        .test();
        testOnSuccessListener.getValue().onSuccess(actionCodeResult);
        testOnCompleteListener.getValue().onComplete(actionCodeResultTask);
        verify(firebaseAuth).checkActionCode(eq(ANY_CODE));
        authTestObserver.assertNoErrors()
        .assertValueCount(1)
        .assertValueSet(Collections.singletonList(actionCodeResult))
        .assertComplete()
        .dispose();

        return null;
    }

    // changes the entity's password to newPassword for the account for which the code is valid.
    // code validity is checked with verifyPasswordResetCode(String)
    // use case is only valid for signed-out entities and undefined for signed-in entities.
    // password changes for signed-in entities is made using UserEntity.updatePassword(String)
    // IllegalArgumentException thrown if pass null code or newPassword
    // AuthAccessCodeException thrown if code is malformed or expired
    // AuthInvalidEntityException thrown if user corresponding to given code has been disabled, or if there is no user corresponding to given code
    public Job<Void> confirmPasswordReset(String code, String newPassword)
        throws IllegalArgumentException, AuthActionCodeException, AuthInvalidUserException, AuthWeakPasswordException {

        @Test
        public void confirmPasswordReset() {
        TestObserver authTestObserver = RxFirebaseAuth
        .confirmPasswordReset(firebaseAuth, ANY_CODE, ANY_PASSWORD)
        .test();
        testOnCompleteListener.getValue().onComplete(voidTask);
        verify(firebaseAuth).confirmPasswordReset(eq(ANY_CODE), eq(ANY_PASSWORD));
        authTestObserver.assertNoErrors()
        .assertValueSet(Collections.singletonList(voidTask))
        .assertComplete()
        .dispose();
        }
        return null;
    }

    // tries to create new user account with given email and password
    // if successful, user is also signed into app
    // signed-in user accessed with getCurrentUser()
    // upon successful completion, Auth.IdTokenListener.onIdTokenChanged(Auth) event is triggered in all registered IdTokenListeners
    // Auth.AuthStateListener.onAuthStateChanged(Auth) event is triggered in all registered AuthStateListeners
    // AuthWeakPasswordException is thrown if password is not strong enough
    // AuthInvalidCredentialException is thrown if email address is malformed
    // AuthEntityCollisionException is thrown if there already exists an account with the given email address
    // return Job of AuthReport with result of operation
    public Job<AppAuthResult> createUserEntity(String email, String password)
        throws AuthWeakPasswordException, AuthInvalidCredentialException, AuthUserCollisionException {
        return null;
    }

    // return the app instance to which this auth belongs
    public App getApp(){
        return null;
    }

    // returns the current signed-in UserEntity or null if there is none
    public UserEntity getCurrentUserEntity(){
    //public Boolean userAuthenticated()
        return FirebaseAuth.getInstance().getCurrentUser() != null;

    }

    // returns an instance of this class corresponding to the default app instance
    public static AppAuth getInstance(){
    //public Boolean userAuthenticated()

        return FirebaseAuth.getInstance().getCurrentUser() != null;

    }

    // triggers the authentication backend to send a password-reset email to the given email address, which must correspond to the an existing user of the app
    public Job<Void> Completable sendPasswordResetEmail(final String email){

        return Completable.create(
        emitter->{
        OnCompleteListener<Void> resultHandler = task->{
        if (task.isSuccessful()) {
        emitter.onComplete();
        } else {
        emitter.onError(getFirebaseError(DatabaseError.fromException(task.getException())));
        }
        };
        FirebaseAuth.getInstance().sendPasswordResetEmail(email).addOnCompleteListener(resultHandler);
        }).subscribeOn(Schedulers.single());


        return null;
    }

    //public Job<Void> sendSignInLinkToEmail(String email){ return null; }

    //public boolean isSIgnInWithEmailLink(String link){ return false; }

    // tries to sign in a user with the given email address and password
    // access the signed-in user with getCurrentUser()
    // upon successful completion, trigger an IdTokenListener.onIdTokenChanged(Auth) event in all registered IdTokenListeners
    // and AuthStateListener.onAuthStateChanged(Auth) event in all registered AuthStateListeners
    // throws InvalidEntityException if user account corresponding to email does not exist or has been disabled
    // throws InvalidCredentialException if the password is wrong
    // return a Job of AuthResult with result of operation
    public Job<AppAuthResult> signInWithEmailAndPassword(final Activity activity, String email, String password)
    {
        FirebaseAuth.getInstance()
        .signInWithEmailAndPassword(email, password)
        .addOnCompleteListener(activity, new OnCompleteListener<AuthResult>() {
    @Override
    public void onComplete(@NonNull Task<AuthResult> task) {
        Log.d(TAG, "performFirebaseLogin:onComplete:" + task.isSuccessful());
        // If sign in fails, display a message to the user. If sign in succeeds
        // the auth state listener will be notified and logic to handle the
        // signed in user can be handled in the listener.
        if (task.isSuccessful()) {
        mOnLoginListener.onSuccess(task.getResult().toString());
        updateFirebaseToken(task.getResult().getUser().getUid(),
        new SharedPrefUtil(activity.getApplicationContext()).getString(Constants.ARG_FIREBASE_TOKEN, null));
        } else {
        mOnLoginListener.onFailure(task.getException().getMessage());
        }
        }
        });

        return null;
    }

    // Tries to sign in a user with the given AuthCredential (phone or email)
    // For all AuthCredential types except EmailAuthCredential, this method will create an account for the user in the case that it didn't exist before.
    // beta feature
    /*public Job<AppAuthResult> signInWithCredential(AuthCredential credential) throws AuthInvalidUserException, AuthInvalidCredentialException, AuthUserCollisionException {
        return null;
    }*/

    // signs out current entity and clears it from non-persistent storage (disk cache)
    // upon success, operation triggers onIdTokenChanged(Auth) event in all registered IdTokenListeners
    // and onAuthStateChanged(Auth) in all registered AuthStateListeners
    public void signOut(){

        if (FirebaseAuth.getInstance().getCurrentUser() != null) {
        FirebaseAuth.getInstance().signOut();
        mOnLogoutListener.onSuccess("Successfully logged out!");
        } else {
        mOnLogoutListener.onFailure("No user logged in yet!");
        }
    }



    // sets the current user to a copy of the given entity, but associated with this Auth's app.
    // if given user isn't valid, the an invalid user exception is returned via Job
    public Job<Void> updateCurrentUserEntity(AppEntity entity){
        return null;
    }

    // checks that code is a valid password reset out of band code
    // code is generated by a call to sendPasswordResetEmail(String) and is valid for a single use
    // return a Job which holds email for which code is applicable
    public Job<String> verifyPasswordResetCode(String code){
        return null;
    }
}
