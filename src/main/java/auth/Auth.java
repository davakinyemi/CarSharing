package auth;

import app.App;
import auth.accesscode.AccessCodeReport;
import auth.listener.IdTokenListener;
import auth.listener.AuthStateListener;
import entity.SuperEntity;
import exception.authexception.*;
import job.Job;

public abstract class Auth {
    // register a listener to changes in super entity (user/admin/vehicle via admin) auth state
    // there can be more than one listener registered at the same time for one or more auth instances
    // listeners call back in the implementation thread on the following events:
    // right after listener is registered
    // when entity signs in
    // when current entity signs out
    // when current entity changes
    public void addAuthStateListener(AuthStateListener listener){

    }


    public void removeAuthStateListener(AuthStateListener listener){

    }

    // registers a listener to changes in id token auth state
    // there can be more than one listener registered at the same time for one or more auth instances
    // listeners call back in implementation thread on the following events:
    // right after listener is registered
    // when a super entity signs in
    // when current entity signs out
    // when current entity changes
    public void addIdTokenListener(IdTokenListener listener){

    }
    public void removeIdTokenListener(IdTokenListener listener){

    }

    // applies the given code (any valid out of band code)
    public Job<Void> applyAccessCode(String code){
        return null;
    }

    // checks that code given is valid.
    // Code is generated by sendPasswordResetEmail(String) or UserEntity.sendEmailVerification
    // Code is valid fora single use
    public Job<AccessCodeReport> checkAccessCode(String code){
        return null;
    }

    // changes the entity's password to newPassword for the account for which the code is valid.
    // code validity is checked with verifyPasswordResetCode(String)
    // use case is only valid for signed-out entities and undefined for signed-in entities.
    // password changes for signed-in entities is made using UserEntity.updatePassword(String)
    // IllegalArgumentException thrown if pass null code or newPassword
    // AuthAccessCodeException thrown if code is malformed or expired
    // AuthInvalidEntityException thrown if user corresponding to given code has been disabled, or if there is no user corresponding to given code
    public Job<Void> confirmPasswordReset(String code, String newPassword) throws IllegalArgumentException, AuthAccessCodeException, AuthInvalidEntityException, AuthWeakPasswordException {
        return null;
    }

    // tries to create new user account with given email and password
    // if successful, user is also signed into app
    // signed-in user accessed with getCurrentUser()
    // upon successful completion, Auth.IdTokenListener.onIdTokenChanged(Auth) event is triggered in all registered IdTokenListeners
    // Auth.AuthStateListener.onAuthStateChanged(Auth) event is triggered in all registered AuthStateListeners

    public Job<AuthReport> createUser(String email, String password) throws AuthWeakPasswordException, AuthInvalidCredentialException, AuthEntityCollisionException {
        return null;
    }


    public App getApp(){
        return null;
    }
    public SuperEntity getCurrentUser(){
        return null;
    }
    public static Auth getInstance(){
        return null;
    }
    public Job<Void> sendPasswordResetEmail(String email){
        return null;
    }
    public Job<Void> sendSignInLinkToEmail(String email){
        return null;
    }
    public Job<AuthReport> SignInWithEmailAndPassword(String email, String password) throws AuthInvalidEntityException, AuthInvalidCredentialException {
        return null;
    }
    public void signOut(){

    }
    public Job<Void> updateCurrentEntity(SuperEntity entity){
        return null;
    }
    public Job<String> verifyPasswordResetCode(String code){
        return null;
    }
}
